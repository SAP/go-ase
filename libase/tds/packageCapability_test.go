// SPDX-FileCopyrightText: 2020 SAP SE
//
// SPDX-License-Identifier: Apache-2.0

package tds

import (
	"fmt"
	"reflect"
	"testing"
)

var valueMaskCases = map[string]struct {
	bytes     []byte
	valueMask *valueMask
}{
	"one byte": {
		bytes: []byte{0b00101000},
		valueMask: &valueMask{
			capabilities: []bool{
				false,
				false,
				false,
				true,
				false,
				true,
			},
		},
	},
	"two bytes": {
		bytes: []byte{0b10001100, 0b01110111},
		valueMask: &valueMask{
			capabilities: []bool{
				true,
				true,
				true,
				false,
				true,
				true,
				true,
				false,
				false,
				false,
				true,
				true,
				false,
				false,
				false,
				true,
			},
		},
	},
}

func TestParseValueMask(t *testing.T) {
	for title, cas := range valueMaskCases {
		t.Run(title, func(t *testing.T) {
			recv := parseValueMask(cas.bytes)
			if recv == nil {
				t.Errorf("Received nil value mask")
				return
			}

			if len(recv.capabilities) < len(cas.bytes)*8 {
				t.Errorf("Invalid number of capabilities, expected at least %d, got %d",
					len(cas.bytes)*8, len(recv.capabilities))
				return
			}

			for capability, isSet := range recv.capabilities {
				expectedCapIsSet := cas.valueMask.getCapability(capability)

				// Capability has been set
				if isSet == expectedCapIsSet {
					continue
				}
				t.Errorf("Capability %d expected to be %v, is %v",
					capability, expectedCapIsSet, isSet)
			}
		},
		)
	}

}

func bytesToString(bs []byte) string {
	s := "["
	for _, b := range bs {
		s += fmt.Sprintf("%08b ", b)
	}
	return s + "]"
}

func TestValueMask_Bytes(t *testing.T) {
	for title, cas := range valueMaskCases {
		t.Run(title, func(t *testing.T) {
			bs := cas.valueMask.Bytes()

			if !reflect.DeepEqual(bs, cas.bytes) {
				t.Errorf("Generated bytes are invalid")
				t.Errorf("Expected: %s", bytesToString(cas.bytes))
				t.Errorf("Received: %s", bytesToString(bs))
			}
		},
		)
	}
}
