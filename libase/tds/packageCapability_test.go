package tds

import (
	"reflect"
	"testing"
)

var valueMaskCases = map[string]struct {
	bytes     []byte
	valueMask *valueMask
}{
	"one byte": {
		bytes: []byte{0b00010100},
		valueMask: &valueMask{
			capabilities: map[int]bool{
				3: true,
				5: true,
			},
		},
	},
	"two bytes": {
		bytes: []byte{0b10001100, 0b01110111},
		valueMask: &valueMask{
			capabilities: map[int]bool{
				1:  true,
				2:  true,
				3:  true,
				5:  true,
				6:  true,
				7:  true,
				11: true,
				12: true,
				16: true,
			},
		},
	},
}

func TestParseValueMask(t *testing.T) {
	for title, cas := range valueMaskCases {
		t.Run(title, func(t *testing.T) {
			recv := parseValueMask(cas.bytes)
			if recv == nil {
				t.Errorf("Received nil value mask")
				return
			}

			if len(recv.capabilities) < len(cas.bytes)*8 {
				t.Errorf("Invalid number of capabilities, expected at least %d, got %d",
					len(cas.bytes)*8, len(recv.capabilities))
				return
			}

			for capability, isSet := range recv.capabilities {
				expectedCapIsSet, ok := cas.valueMask.capabilities[capability]

				// Check if capability has been set in cas.expected
				if !ok {
					// Capability has not been set - must be false in
					// recv.
					if !isSet {
						continue
					}
					t.Errorf("Unexpected set capability: %d", capability)
					continue
				}

				// Capability has been set
				if isSet == expectedCapIsSet {
					continue
				}
				t.Errorf("Capability %d expected to be %v, is %v",
					capability, expectedCapIsSet, isSet)
			}
		},
		)
	}

}

func TestValueMask_Bytes(t *testing.T) {
	for title, cas := range valueMaskCases {
		t.Run(title, func(t *testing.T) {
			bs := cas.valueMask.Bytes()

			if !reflect.DeepEqual(bs, cas.bytes) {
				t.Errorf("Generated bytes are invalid")
				t.Errorf("Expected: %b", cas.bytes)
				t.Errorf("Received: %b", bs)
			}
		},
		)
	}
}
